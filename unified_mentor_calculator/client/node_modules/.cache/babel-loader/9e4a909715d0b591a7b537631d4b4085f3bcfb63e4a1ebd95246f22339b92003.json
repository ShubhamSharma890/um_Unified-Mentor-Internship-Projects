{"ast":null,"code":"import { createHistory } from \"./apiHelper\";\nexport const handleKeyButtonPress = (btn, buttonsRef) => {\n  if (btn === \"=\") {\n    buttonsRef.current[btn].click();\n    buttonsRef.current[btn].classList.add(\"ring-2\", \"ring-blue-500\");\n    setTimeout(() => {\n      buttonsRef.current[btn].classList.remove(\"ring-2\", \"ring-blue-500\");\n    }, 200);\n  }\n};\nexport const handleBackspace = (inputValue, setInputValue) => {\n  if (inputValue.length > 0) {\n    const lastInputValue = inputValue[inputValue.length - 1];\n    if (lastInputValue.type === \"number\" && lastInputValue.value.toString().length > 1) {\n      // if last input value is number and more than 1 remove last charc\n      const newInputValue = {\n        ...lastInputValue,\n        value: lastInputValue.value.slice(0, -1),\n        label: lastInputValue.value.slice(0, -1)\n      };\n      // update input\n      setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n    } else {\n      // remove whole last value\n      setInputValue(prev => [...prev.slice(0, -1)]);\n    }\n  }\n};\nexport const handleButtonType = (button, inputValue, lastInputValue, setInputValue, setResult, setCalculated, calculated) => {\n  let operation;\n  switch (button.type) {\n    case \"number\":\n      handleNumber(button.value, lastInputValue, setInputValue, button, calculated);\n      break;\n    case \"operator\":\n      handleOperator(inputValue, lastInputValue, setInputValue, button);\n      break;\n    case \"plusminus\":\n      operation = nums => -nums;\n      handleUnaryOperations(operation, lastInputValue, setInputValue);\n      break;\n    case \"percent\":\n      operation = nums => nums / 100;\n      handleUnaryOperations(operation, lastInputValue, setInputValue);\n      break;\n    case \"dot\":\n      handleDot(lastInputValue, setInputValue);\n      break;\n    case \"clear\":\n      handleClear(setInputValue, setResult, setCalculated);\n      break;\n    case \"equal\":\n      handleEqual(inputValue, setInputValue, setResult, setCalculated);\n      break;\n    default:\n      console.error(`Unhandled button type: ${button.type}`);\n      break;\n  }\n};\n\n//handle unanary operations\nconst handleUnaryOperations = (operation, lastInputValue, setInputValue) => {\n  if (lastInputValue && lastInputValue.type === \"number\") {\n    // perform the function on last value\n    const newInputValue = {\n      ...lastInputValue,\n      value: operation(lastInputValue.value),\n      label: operation(lastInputValue.value)\n    };\n\n    // update the value in inputValue array\n    setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n  }\n};\n\n// handle Numbers\nconst handleNumber = (value, lastInputValue, setInputValue, button, calculated) => {\n  if (lastInputValue && lastInputValue.type === \"number\") {\n    // if last value is a number add in the last value\n    let newValue = lastInputValue.value;\n    if (lastInputValue.value.toString().length < 15) {\n      // add a limit of 15 characters\n      newValue = calculated ? value : lastInputValue.value + value;\n    }\n    const newInputValue = {\n      ...lastInputValue,\n      value: newValue,\n      label: newValue\n    };\n\n    // update new value\n    setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n  } else {\n    // if last value is not a number then add current as a new value\n    setInputValue(prev => [...prev, button]);\n  }\n};\nconst handleOperator = (inputValue, lastInputValue, setInputValue, button) => {\n  if (inputValue.length > 0) {\n    // only allow operator if input value not empty\n    // if last value is operator replace it\n    if (lastInputValue && lastInputValue.type === \"operator\") {\n      const newInputValue = {\n        ...lastInputValue,\n        value: button.value,\n        label: button.label\n      };\n      setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n    } else {\n      // restrict calc to two values\n      if (!(inputValue.length > 2)) {\n        // add operator\n        setInputValue(prev => [...prev.slice(0, -1), lastInputValue, button]);\n      }\n    }\n  }\n};\nconst handleDot = (lastInputValue, setInputValue) => {\n  if (lastInputValue && lastInputValue.type === \"number\") {\n    // if last value is number add dot\n    let newValue = lastInputValue.value;\n    if (!lastInputValue.value.includes(\".\")) {\n      // if dot does not already exist add one\n      newValue = lastInputValue.value + \".\";\n    }\n    const newInputValue = {\n      ...lastInputValue,\n      value: newValue,\n      label: newValue\n    };\n\n    // update values\n    setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n  } else if (!lastInputValue || lastInputValue.type !== \"number\") {\n    // if there is no last value or its not a number\n    const newInputValue = {\n      value: \"0.\",\n      label: \"0.\",\n      type: \"number\"\n    };\n    setInputValue(prev => [...prev, newInputValue]);\n  }\n};\nconst handleClear = (setInputValue, setResult, setCalculated) => {\n  setInputValue([]);\n  setResult(0);\n  setCalculated(false);\n};\nconst handleEqual = (inputValue, setInputValue, setResult, setCalculated) => {\n  if (inputValue.length > 0) {\n    calculate(inputValue, setInputValue, setResult, setCalculated);\n  }\n};\nconst calculate = async (inputValue, setInputValue, setResult, setCalculated) => {\n  const inputValueToCalculate = [...inputValue];\n  const lastInputValue = inputValueToCalculate[inputValueToCalculate.length - 1];\n\n  // check if last value is operator\n  if (lastInputValue && lastInputValue.type === \"operator\") {\n    inputValueToCalculate.pop();\n    setInputValue(inputValueToCalculate);\n  }\n\n  // create expression from input value\n  const expression = inputValueToCalculate.map(item => {\n    // remove leading zero\n    if (item.type === \"number\") {\n      return Number(item.value);\n    }\n    return item.value;\n  }).join(\"\");\n  // save the expression\n\n  // solve expression\n  try {\n    const newResult = eval(expression);\n    if (isNaN(newResult) || !isFinite(newResult)) {\n      // if error\n      setResult(\"NaN\");\n      throw new Error(\"invalid expression\");\n    }\n    setResult(newResult);\n    setCalculated(true);\n    setInputValue([]);\n\n    //save calculation history\n    const payload = {\n      expression,\n      result: newResult\n    };\n    await createHistory(payload);\n  } catch (err) {\n    console.log(\"err: \", err.message);\n  }\n};","map":{"version":3,"names":["createHistory","handleKeyButtonPress","btn","buttonsRef","current","click","classList","add","setTimeout","remove","handleBackspace","inputValue","setInputValue","length","lastInputValue","type","value","toString","newInputValue","slice","label","prev","handleButtonType","button","setResult","setCalculated","calculated","operation","handleNumber","handleOperator","nums","handleUnaryOperations","handleDot","handleClear","handleEqual","console","error","newValue","includes","calculate","inputValueToCalculate","pop","expression","map","item","Number","join","newResult","eval","isNaN","isFinite","Error","payload","result","err","log","message"],"sources":["D:/Unified Mentor/React/UM_BasicCalcProject/client/src/components/helper/calculate.js"],"sourcesContent":["import { createHistory } from \"./apiHelper\";\n\nexport const handleKeyButtonPress = (btn, buttonsRef) => {\n  if (btn === \"=\") {\n    buttonsRef.current[btn].click();\n\n    buttonsRef.current[btn].classList.add(\"ring-2\", \"ring-blue-500\");\n\n    setTimeout(() => {\n      buttonsRef.current[btn].classList.remove(\"ring-2\", \"ring-blue-500\");\n    }, 200);\n  }\n};\n\nexport const handleBackspace = (inputValue, setInputValue) => {\n  if (inputValue.length > 0) {\n    const lastInputValue = inputValue[inputValue.length - 1];\n    if (\n      lastInputValue.type === \"number\" &&\n      lastInputValue.value.toString().length > 1\n    ) {\n      // if last input value is number and more than 1 remove last charc\n      const newInputValue = {\n        ...lastInputValue,\n        value: lastInputValue.value.slice(0, -1),\n        label: lastInputValue.value.slice(0, -1),\n      };\n      // update input\n      setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n    } else {\n      // remove whole last value\n      setInputValue(prev => [...prev.slice(0, -1)]);\n    }\n  }\n};\n\nexport const handleButtonType = (\n  button,\n  inputValue,\n  lastInputValue,\n  setInputValue,\n  setResult,\n  setCalculated,\n  calculated\n) => {\n  let operation;\n\n  switch (button.type) {\n    case \"number\":\n      handleNumber(\n        button.value,\n        lastInputValue,\n        setInputValue,\n        button,\n        calculated\n      );\n      break;\n    case \"operator\":\n      handleOperator(inputValue, lastInputValue, setInputValue, button);\n      break;\n    case \"plusminus\":\n      operation = nums => -nums;\n      handleUnaryOperations(operation, lastInputValue, setInputValue);\n      break;\n    case \"percent\":\n      operation = nums => nums / 100;\n      handleUnaryOperations(operation, lastInputValue, setInputValue);\n      break;\n    case \"dot\":\n      handleDot(lastInputValue, setInputValue);\n      break;\n    case \"clear\":\n      handleClear(setInputValue, setResult, setCalculated);\n      break;\n    case \"equal\":\n      handleEqual(inputValue, setInputValue, setResult, setCalculated);\n      break;\n    default:\n      console.error(`Unhandled button type: ${button.type}`);\n      break;\n  }\n};\n\n//handle unanary operations\nconst handleUnaryOperations = (operation, lastInputValue, setInputValue) => {\n  if (lastInputValue && lastInputValue.type === \"number\") {\n    // perform the function on last value\n    const newInputValue = {\n      ...lastInputValue,\n      value: operation(lastInputValue.value),\n      label: operation(lastInputValue.value),\n    };\n\n    // update the value in inputValue array\n    setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n  }\n};\n\n// handle Numbers\nconst handleNumber = (\n  value,\n  lastInputValue,\n  setInputValue,\n  button,\n  calculated\n) => {\n  if (lastInputValue && lastInputValue.type === \"number\") {\n    // if last value is a number add in the last value\n    let newValue = lastInputValue.value;\n    if (lastInputValue.value.toString().length < 15) {\n      // add a limit of 15 characters\n      newValue = calculated ? value : lastInputValue.value + value;\n    }\n    const newInputValue = {\n      ...lastInputValue,\n      value: newValue,\n      label: newValue,\n    };\n\n    // update new value\n    setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n  } else {\n    // if last value is not a number then add current as a new value\n    setInputValue(prev => [...prev, button]);\n  }\n};\n\nconst handleOperator = (inputValue, lastInputValue, setInputValue, button) => {\n  if (inputValue.length > 0) {\n    // only allow operator if input value not empty\n    // if last value is operator replace it\n    if (lastInputValue && lastInputValue.type === \"operator\") {\n      const newInputValue = {\n        ...lastInputValue,\n        value: button.value,\n        label: button.label,\n      };\n      setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n    } else {\n      // restrict calc to two values\n      if (!(inputValue.length > 2)) {\n        // add operator\n        setInputValue(prev => [...prev.slice(0, -1), lastInputValue, button]);\n      }\n    }\n  }\n};\n\nconst handleDot = (lastInputValue, setInputValue) => {\n  if (lastInputValue && lastInputValue.type === \"number\") {\n    // if last value is number add dot\n    let newValue = lastInputValue.value;\n    if (!lastInputValue.value.includes(\".\")) {\n      // if dot does not already exist add one\n      newValue = lastInputValue.value + \".\";\n    }\n\n    const newInputValue = {\n      ...lastInputValue,\n      value: newValue,\n      label: newValue,\n    };\n\n    // update values\n    setInputValue(prev => [...prev.slice(0, -1), newInputValue]);\n  } else if (!lastInputValue || lastInputValue.type !== \"number\") {\n    // if there is no last value or its not a number\n    const newInputValue = { value: \"0.\", label: \"0.\", type: \"number\" };\n\n    setInputValue(prev => [...prev, newInputValue]);\n  }\n};\n\nconst handleClear = (setInputValue, setResult, setCalculated) => {\n  setInputValue([]);\n  setResult(0);\n  setCalculated(false);\n};\n\nconst handleEqual = (inputValue, setInputValue, setResult, setCalculated) => {\n  if (inputValue.length > 0) {\n    calculate(inputValue, setInputValue, setResult, setCalculated);\n  }\n};\n\nconst calculate = async (\n  inputValue,\n  setInputValue,\n  setResult,\n  setCalculated\n) => {\n  const inputValueToCalculate = [...inputValue];\n\n  const lastInputValue =\n    inputValueToCalculate[inputValueToCalculate.length - 1];\n\n  // check if last value is operator\n  if (lastInputValue && lastInputValue.type === \"operator\") {\n    inputValueToCalculate.pop();\n    setInputValue(inputValueToCalculate);\n  }\n\n  // create expression from input value\n  const expression = inputValueToCalculate\n    .map(item => {\n      // remove leading zero\n      if (item.type === \"number\") {\n        return Number(item.value);\n      }\n      return item.value;\n    })\n    .join(\"\");\n  // save the expression\n\n  // solve expression\n  try {\n    const newResult = eval(expression);\n    if (isNaN(newResult) || !isFinite(newResult)) {\n      // if error\n      setResult(\"NaN\");\n      throw new Error(\"invalid expression\");\n    }\n    setResult(newResult);\n    setCalculated(true);\n    setInputValue([]);\n\n    //save calculation history\n    const payload = {\n      expression,\n      result: newResult,\n    };\n    await createHistory(payload);\n  } catch (err) {\n    console.log(\"err: \", err.message);\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}